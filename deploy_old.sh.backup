#!/bin/bash

# 求职管理系统一键部署脚本
# 作者: GitHub Copilot
# 日期: 2025-10-23
# 用法: bash deploy.sh [dev|prod]

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 项目路径（根据实际情况修改）
PROJECT_DIR="/root/JobApplyManagement"

# 打印带颜色的消息
print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

print_header() {
    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
}

# 显示使用帮助
show_help() {
    echo ""
    echo "🚀 求职管理系统一键部署脚本"
    echo ""
    echo "用法:"
    echo "  bash deploy.sh [模式]"
    echo ""
    echo "模式:"
    echo "  dev   - 开发模式（使用 Vite 开发服务器，支持热更新）"
    echo "  prod  - 生产模式（构建静态文件并部署到 /var/www）"
    echo ""
    echo "示例:"
    echo "  bash deploy.sh dev   # 开发模式部署"
    echo "  bash deploy.sh prod  # 生产模式部署"
    echo ""
}

# 检查必要的命令
check_dependencies() {
    print_header "检查系统依赖"
    
    local missing_deps=()
    
    if ! command -v node &> /dev/null; then
        missing_deps+=("node")
    fi
    
    if ! command -v npm &> /dev/null; then
        missing_deps+=("npm")
    fi
    
    if ! command -v pm2 &> /dev/null; then
        missing_deps+=("pm2")
    fi
    
    if ! command -v nginx &> /dev/null; then
        missing_deps+=("nginx")
    fi
    
    if ! command -v psql &> /dev/null; then
        missing_deps+=("postgresql-client")
    fi
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        print_error "缺少以下依赖: ${missing_deps[*]}"
        echo ""
        echo "请先安装缺少的依赖："
        echo "  sudo apt update"
        echo "  sudo apt install -y nodejs npm postgresql-client nginx"
        echo "  sudo npm install -g pm2"
        exit 1
    fi
    
    print_success "所有依赖已安装"
}

# 检查项目目录
check_project_dir() {
    print_header "检查项目目录"
    
    if [ ! -d "$PROJECT_DIR" ]; then
        print_error "项目目录不存在: $PROJECT_DIR"
        echo ""
        echo "请修改脚本中的 PROJECT_DIR 变量为实际项目路径"
        exit 1
    fi
    
    cd "$PROJECT_DIR"
    print_success "项目目录: $PROJECT_DIR"
}

# 检查数据库连接
check_database() {
    print_header "检查数据库连接"
    
    # 从 .env 文件读取数据库配置
    if [ -f ".env" ]; then
        # 使用 grep 而不是 source 来避免变量污染
        DB_USER=$(grep "^DB_USER=" .env | cut -d '=' -f2)
        DB_NAME=$(grep "^DB_NAME=" .env | cut -d '=' -f2)
        DB_HOST=$(grep "^DB_HOST=" .env | cut -d '=' -f2)
        DB_PASSWORD=$(grep "^DB_PASSWORD=" .env | cut -d '=' -f2)
    fi
    
    # 使用默认值
    DB_USER=${DB_USER:-lthero}
    DB_NAME=${DB_NAME:-job_tracker}
    DB_HOST=${DB_HOST:-localhost}
    DB_PASSWORD=${DB_PASSWORD:-}
    
    # 使用 PGPASSWORD 环境变量提供密码
    if PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1;" > /dev/null 2>&1; then
        print_success "数据库连接正常"
    else
        print_warning "数据库连接失败"
        print_info "请确保 PostgreSQL 正在运行并且配置正确"
        print_info "数据库配置: 主机=$DB_HOST 用户=$DB_USER 数据库=$DB_NAME"
        
        read -p "是否继续部署？(y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
}

# 安装依赖
install_dependencies() {
    print_header "安装项目依赖"
    
    if [ ! -d "node_modules" ]; then
        print_info "安装 npm 依赖..."
        npm install
        print_success "依赖安装完成"
    else
        print_info "检查依赖更新..."
        npm install
        print_success "依赖已是最新"
    fi
}

# 配置环境变量 - 开发模式
configure_env_dev() {
    print_header "配置环境变量（开发模式）"
    
    # 检查是否已有 .env 文件
    if [ -f ".env" ]; then
        print_warning "检测到现有 .env 文件"
        cat .env
        echo ""
        read -p "是否保留现有配置？(Y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Nn]$ ]]; then
            # 用户选择重新配置
            create_new_env_file "dev"
        else
            print_success "保留现有 .env 配置"
        fi
    else
        # 没有 .env 文件，创建新的
        create_new_env_file "dev"
    fi
}

# 配置环境变量 - 生产模式
configure_env_prod() {
    print_header "配置环境变量（生产模式）"
    
    # 检查是否已有 .env 文件
    if [ -f ".env" ]; then
        print_warning "检测到现有 .env 文件"
        cat .env
        echo ""
        read -p "是否保留现有配置？(Y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Nn]$ ]]; then
            # 用户选择重新配置
            create_new_env_file "prod"
        else
            print_success "保留现有 .env 配置"
        fi
    else
        # 没有 .env 文件，创建新的
        create_new_env_file "prod"
    fi
}

# 创建新的 .env 文件（交互式或使用模板）
create_new_env_file() {
    local mode=$1
    
    echo ""
    print_info "请选择配置方式:"
    echo "  1) 使用示例模板（需要手动修改）"
    echo "  2) 交互式输入配置"
    read -p "请选择 (1/2): " -n 1 -r
    echo
    echo ""
    
    if [[ $REPLY == "2" ]]; then
        # 交互式输入
        print_info "请输入配置信息:"
        
        read -p "数据库主机 [localhost]: " DB_HOST
        DB_HOST=${DB_HOST:-localhost}
        
        read -p "数据库端口 [5432]: " DB_PORT
        DB_PORT=${DB_PORT:-5432}
        
        read -p "数据库名称 [job_tracker]: " DB_NAME
        DB_NAME=${DB_NAME:-job_tracker}
        
        read -p "数据库用户 [postgres]: " DB_USER
        DB_USER=${DB_USER:-postgres}
        
        read -sp "数据库密码: " DB_PASSWORD
        echo
        
        read -p "前端域名 (如: https://yourdomain.com): " FRONTEND_URL
        
        read -p "JWT密钥 (留空自动生成): " JWT_SECRET
        if [ -z "$JWT_SECRET" ]; then
            JWT_SECRET=$(openssl rand -base64 32 2>/dev/null || echo "please-change-this-secret-key-$(date +%s)")
        fi
        
        # 生成 .env 文件
        cat > .env << EOF
# 后端配置
PORT=3000
DB_HOST=$DB_HOST
DB_PORT=$DB_PORT
DB_NAME=$DB_NAME
DB_USER=$DB_USER
DB_PASSWORD=$DB_PASSWORD
JWT_SECRET=$JWT_SECRET

# 前端配置
FRONTEND_URL=$FRONTEND_URL
VITE_API_URL=${FRONTEND_URL}/api
EOF
        
        print_success "环境变量配置完成"
        
    else
        # 使用模板
        cat > .env << 'EOF'
# 后端配置
PORT=3000
DB_HOST=localhost
DB_PORT=5432
DB_NAME=job_tracker
DB_USER=postgres
DB_PASSWORD=YOUR_DATABASE_PASSWORD_HERE
JWT_SECRET=your-secret-key-change-in-production-use-random-string-at-least-32-characters-long

# 前端配置
FRONTEND_URL=https://yourdomain.com
VITE_API_URL=https://yourdomain.com/api
EOF
        
        print_success "已创建 .env 模板文件"
        print_warning "⚠️  请立即编辑 .env 文件，修改以下配置:"
        print_warning "   - DB_PASSWORD: 设置数据库密码"
        print_warning "   - FRONTEND_URL: 设置你的域名"
        print_warning "   - JWT_SECRET: 设置安全的密钥"
        echo ""
        read -p "按回车继续编辑 .env 文件..." 
        ${EDITOR:-vim} .env
    fi
}

# 配置 Vite
configure_vite() {
    print_header "配置 Vite"
    
    cat > vite.config.js << 'EOF'
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  build: {
    outDir: 'dist',
    emptyOutDir: true,
  },
  server: {
    host: true,
    port: 5173,
  }
})
EOF
    
    print_success "Vite 配置完成"
}

# 启动后端
start_backend() {
    print_header "启动后端服务"
    
    # 停止旧的后端进程
    pm2 delete job-tracker 2>/dev/null || true
    
    # 启动新的后端进程
    pm2 start server/server.js --name job-tracker
    
    # 等待启动
    sleep 3
    
    # 检查状态
    if pm2 list | grep -q "job-tracker.*online"; then
        print_success "后端服务启动成功"
    else
        print_error "后端服务启动失败"
        pm2 logs job-tracker --lines 20
        exit 1
    fi
    
    # 测试 API
    if curl -s http://localhost:3000/api/health > /dev/null 2>&1; then
        print_success "后端 API 正常响应"
    else
        print_warning "后端 API 无响应，请检查日志: pm2 logs job-tracker"
    fi
}

# 开发模式部署
deploy_dev() {
    print_header "🔧 开发模式部署"
    
    # 配置环境变量
    configure_env_dev
    
    # 配置 Vite
    configure_vite
    
    # 启动后端
    start_backend
    
    # 修复权限
    print_header "修复文件权限"
    chmod 755 /root
    chmod 755 "$PROJECT_DIR"
    if [ -d "dist" ]; then
        chmod -R 755 dist
    fi
    print_success "权限修复完成"
    
    # 停止旧的前端进程
    print_header "启动前端开发服务器"
    pm2 delete vite 2>/dev/null || true
    
    # 启动 Vite 开发服务器
    pm2 start npm --name vite -- run dev -- --host 0.0.0.0 --port 8081
    
    # 等待启动
    sleep 5
    
    # 检查状态
    if pm2 list | grep -q "vite.*online"; then
        print_success "前端开发服务器启动成功"
    else
        print_error "前端开发服务器启动失败"
        pm2 logs vite --lines 20
        exit 1
    fi
    
    # 配置 Nginx
    configure_nginx "dev"
    
    # 测试访问
    test_deployment
    
    # 显示部署结果  
    show_deployment_result "dev"
}

# 配置 Nginx
configure_nginx() {
    local mode=$1  # dev 或 prod
    
    print_header "配置 Nginx（${mode}模式）"
    
    # 从 .env 读取域名
    if [ -f ".env" ]; then
        DOMAIN=$(grep "^FRONTEND_URL=" .env | cut -d '=' -f2 | sed 's|https://||' | sed 's|http://||' | sed 's|/||g')
    fi
    
    if [ -z "$DOMAIN" ]; then
        print_warning "未找到域名配置"
        read -p "请输入域名 (如: yourdomain.com): " DOMAIN
    fi
    
    print_info "配置域名: $DOMAIN"
    
    # 检查 SSL 证书是否存在
    SSL_CERT="/etc/letsencrypt/live/$DOMAIN/fullchain.pem"
    if [ ! -f "$SSL_CERT" ]; then
        print_warning "未找到 SSL 证书: $SSL_CERT"
        print_info "请确保已经申请 Let's Encrypt 证书"
        print_info "或者手动配置 Nginx SSL 证书路径"
        read -p "是否继续配置 Nginx？(y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            return
        fi
    fi
    
    if [ "$mode" == "dev" ]; then
        # 开发模式：代理到 Vite 开发服务器
        sudo tee /etc/nginx/sites-available/job-tracker > /dev/null << NGINXEOF
# HTTP 重定向到 HTTPS
server {
    listen 80;
    server_name $DOMAIN;
    return 301 https://\$host\$request_uri;
}

# HTTPS 主配置
server {
    listen 443 ssl http2;
    server_name $DOMAIN;

    # SSL 证书
    ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # 安全头
    add_header Strict-Transport-Security "max-age=31536000" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;

    # 日志
    access_log /var/log/nginx/job-access.log;
    error_log /var/log/nginx/job-error.log;

    # API 反向代理
    location /api/ {
        proxy_pass http://127.0.0.1:3000/api/;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass \$http_upgrade;
    }

    # 前端代理到开发服务器
    location / {
        proxy_pass http://127.0.0.1:8081;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_cache_bypass \$http_upgrade;
    }
}
NGINXEOF
    else
        # 生产模式：提供静态文件
        sudo tee /etc/nginx/sites-available/job-tracker > /dev/null << NGINXEOF
# HTTP 重定向到 HTTPS
server {
    listen 80;
    server_name $DOMAIN;
    return 301 https://\$host\$request_uri;
}

# HTTPS 主配置
server {
    listen 443 ssl http2;
    server_name $DOMAIN;

    # SSL 证书
    ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # 安全头
    add_header Strict-Transport-Security "max-age=31536000" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;

    # 日志
    access_log /var/log/nginx/job-access.log;
    error_log /var/log/nginx/job-error.log;

    # API 反向代理
    location /api/ {
        proxy_pass http://127.0.0.1:3000/api/;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass \$http_upgrade;
    }

    # 前端静态文件
    location / {
        root /var/www/job-tracker;
        try_files \$uri \$uri/ /index.html;
        index index.html;
    }

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)\$ {
        root /var/www/job-tracker;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
}
NGINXEOF
    fi
    
    sudo ln -sf /etc/nginx/sites-available/job-tracker /etc/nginx/sites-enabled/
    
    # 测试并重载 Nginx
    if sudo nginx -t; then
        print_success "Nginx 配置正确"
        sudo systemctl reload nginx
        print_success "Nginx 已重载"
    else
        print_error "Nginx 配置错误"
        exit 1
    fi
}
    
    # 测试访问
    print_header "测试访问"
    sleep 2
    
    print_info "测试 API..."
    if curl -s https://job.lthero.cn/api/health | grep -q "success"; then
        print_success "API 正常"
    else
        print_warning "API 可能未正常响应"
    fi
    
    # 显示部署结果
    print_header "🎉 开发模式部署完成"
    echo ""
    echo "📊 服务状态:"
    pm2 list | grep -E "job-tracker|vite"
    echo ""
    echo "🌐 访问地址:"
    echo "  - 前端: https://job.lthero.cn"
    echo "  - API:  https://job.lthero.cn/api"
    echo ""
    echo "📋 管理命令:"
    echo "  - 查看后端日志: pm2 logs job-tracker"
    echo "  - 查看前端日志: pm2 logs vite"
    echo "  - 重启后端:    pm2 restart job-tracker"
    echo "  - 重启前端:    pm2 restart vite"
    echo "  - 查看所有进程: pm2 list"
    echo ""
    echo "💡 提示:"
    echo "  - 开发模式支持热更新（HMR）"
    echo "  - 修改代码后会自动刷新浏览器"
    echo "  - 如需切换到生产模式，运行: bash deploy.sh prod"
    echo ""
}

# 生产模式部署
deploy_prod() {
    print_header "🚀 生产模式部署"
    
    # 配置环境变量
    configure_env_prod
    
    # 配置 Vite
    configure_vite
    
    # 清理旧文件
    print_header "清理旧构建文件"
    rm -rf dist build node_modules/.vite
    print_success "清理完成"
    
    # 构建前端
    print_header "构建前端"
    npm run build
    
    # 检查构建结果
    if [ ! -d "dist" ]; then
        print_error "构建失败！dist 目录不存在"
        exit 1
    fi
    
    print_success "前端构建成功"
    echo ""
    print_info "构建产物:"
    ls -lh dist/ | head -10
    echo ""
    
    # 部署到 /var/www
    print_header "部署静态文件到 /var/www"
    sudo mkdir -p /var/www/job-tracker
    sudo rm -rf /var/www/job-tracker/*
    sudo cp -r dist/* /var/www/job-tracker/
    sudo chown -R www-data:www-data /var/www/job-tracker
    sudo chmod -R 755 /var/www/job-tracker
    print_success "静态文件部署完成"
    
    # 启动后端
    start_backend
    
    # 停止开发服务器（如果在运行）
    pm2 delete vite 2>/dev/null || true
    
    # 配置 Nginx
    print_header "配置 Nginx（生产模式）"
    
    sudo tee /etc/nginx/sites-available/job-tracker > /dev/null << 'NGINXEOF'
# HTTP 重定向到 HTTPS
server {
    listen 80;
    server_name job.lthero.cn;
    return 301 https://$host$request_uri;
}

# HTTPS 主配置
server {
    listen 443 ssl http2;
    server_name job.lthero.cn;

    # SSL 证书
    ssl_certificate /etc/letsencrypt/live/job.lthero.cn/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/job.lthero.cn/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # 安全头
    add_header Strict-Transport-Security "max-age=31536000" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;

    # 日志
    access_log /var/log/nginx/job-access.log;
    error_log /var/log/nginx/job-error.log;

    # API 反向代理
    location /api/ {
        proxy_pass http://127.0.0.1:3000/api/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass $http_upgrade;
    }

    # 前端静态文件
    location / {
        root /var/www/job-tracker;
        try_files $uri $uri/ /index.html;
        index index.html;
    }

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        root /var/www/job-tracker;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
}
NGINXEOF
    
    sudo ln -sf /etc/nginx/sites-available/job-tracker /etc/nginx/sites-enabled/
    
    # 测试并重载 Nginx
    if sudo nginx -t; then
        print_success "Nginx 配置正确"
        sudo systemctl reload nginx
        print_success "Nginx 已重载"
    else
        print_error "Nginx 配置错误"
        exit 1
    fi
    
    # 测试访问
    print_header "测试访问"
    sleep 2
    
    print_info "测试 API..."
    if curl -s https://job.lthero.cn/api/health | grep -q "success"; then
        print_success "API 正常"
    else
        print_warning "API 可能未正常响应"
    fi
    
    print_info "测试首页..."
    HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://job.lthero.cn/)
    if [ "$HTTP_CODE" = "200" ]; then
        print_success "首页正常 (HTTP $HTTP_CODE)"
    else
        print_warning "首页返回 HTTP $HTTP_CODE"
    fi
    
    # 显示部署结果
    print_header "🎉 生产模式部署完成"
    echo ""
    echo "📊 服务状态:"
    pm2 list | grep job-tracker
    echo ""
    echo "🌐 访问地址:"
    echo "  - 前端: https://job.lthero.cn"
    echo "  - API:  https://job.lthero.cn/api"
    echo ""
    echo "📦 部署信息:"
    echo "  - 静态文件: /var/www/job-tracker"
    echo "  - 后端服务: PM2 管理 (job-tracker)"
    echo ""
    echo "📋 管理命令:"
    echo "  - 查看后端日志:   pm2 logs job-tracker"
    echo "  - 重启后端:      pm2 restart job-tracker"
    echo "  - 查看进程状态:   pm2 list"
    echo "  - 查看 Nginx 日志: sudo tail -f /var/log/nginx/job-error.log"
    echo ""
    echo "💡 提示:"
    echo "  - 静态文件已优化（Gzip + 缓存）"
    echo "  - 修改代码后需重新构建: bash deploy.sh prod"
    echo "  - 如需切换到开发模式，运行: bash deploy.sh dev"
    echo ""
}

# 主函数
main() {
    # 显示标题
    echo ""
    echo "╔════════════════════════════════════════╗"
    echo "║   求职管理系统 - 一键部署脚本          ║"
    echo "╚════════════════════════════════════════╝"
    echo ""
    
    # 检查参数
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    MODE=$1
    
    # 验证模式参数
    if [ "$MODE" != "dev" ] && [ "$MODE" != "prod" ]; then
        print_error "无效的部署模式: $MODE"
        show_help
        exit 1
    fi
    
    # 确认部署
    echo "部署模式: $([ "$MODE" == "dev" ] && echo "开发模式 (Development)" || echo "生产模式 (Production)")"
    echo "项目路径: $PROJECT_DIR"
    echo ""
    read -p "确认部署？(y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_warning "部署已取消"
        exit 0
    fi
    echo ""
    
    # 检查依赖
    check_dependencies
    
    # 检查项目目录
    check_project_dir
    
    # 检查数据库
    check_database
    
    # 安装依赖
    install_dependencies
    
    # 根据模式部署
    if [ "$MODE" == "dev" ]; then
        deploy_dev
    else
        deploy_prod
    fi
    
    # 配置防火墙
    print_header "配置防火墙（安全加固）"
    
    if command -v ufw &> /dev/null; then
        print_info "检测到 UFW 防火墙，配置安全规则..."
        
        # 允许 SSH（重要！）
        sudo ufw allow 22/tcp
        
        # 允许 HTTP 和 HTTPS
        sudo ufw allow 80/tcp
        sudo ufw allow 443/tcp
        
        # 确保后端端口不对外开放（只监听 localhost）
        # 检查是否有规则开放了 3000 端口
        if sudo ufw status | grep -q "3000"; then
            print_warning "检测到 3000 端口已开放，建议关闭"
            read -p "是否关闭 3000 端口的外网访问？(Y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
                sudo ufw delete allow 3000/tcp 2>/dev/null || true
                print_success "已关闭 3000 端口的外网访问"
            fi
        fi
        
        # 启用防火墙
        print_info "启用防火墙..."
        echo "y" | sudo ufw enable
        
        echo ""
        print_success "防火墙配置完成"
        echo ""
        print_info "当前防火墙规则:"
        sudo ufw status numbered
        echo ""
        print_warning "安全提示: 后端 3000 端口只应监听 localhost，不对外开放"
    else
        print_warning "未检测到 UFW 防火墙"
        echo ""
        print_info "建议手动配置防火墙规则:"
        echo "  sudo apt install ufw"
        echo "  sudo ufw allow 22/tcp   # SSH"
        echo "  sudo ufw allow 80/tcp   # HTTP"
        echo "  sudo ufw allow 443/tcp  # HTTPS"
        echo "  sudo ufw enable"
        echo ""
        print_warning "重要: 不要开放 3000 端口！"
    fi
    
    # 保存 PM2 配置
    print_header "保存 PM2 配置"
    pm2 save
    print_success "PM2 配置已保存"
    
    # 完成
    echo ""
    print_success "所有部署步骤已完成！"
    echo ""
}

# 执行主函数
main "$@"
